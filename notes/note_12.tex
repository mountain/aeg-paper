\documentclass[12pt]{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{hyperref}

\title{A Toy Model of Paths, Loops, and Homology in Expression Geometry}
\author{Notes for Mingli Yuan}
\date{}

\begin{document}
\maketitle

\begin{abstract}
This note formalizes the discussion of a minimal T/D--expression world in which
computation, homotopy, homology, and cochains can be studied together.
The goal is to expose a structural bridge between \emph{computation paths},
\emph{rewrite equivalences}, \emph{2--cell fillings}, and
\emph{algorithmic invariants}, and to show how this structure naturally extends
to modern notions of learning.
\end{abstract}

\section{The T/D Expression World}

We study expressions generated from a constant $0$ using only two operators:
\[
T: x \mapsto x+1,
\qquad
D: x \mapsto 2x.
\]
Each syntactic expression is treated as a node, without identifying expressions
of the same numerical value.

\subsection*{Semantics}
The value of an expression $E$ is defined recursively:
\[
\llbracket 0 \rrbracket = 0, \qquad
\llbracket T(E) \rrbracket = \llbracket E \rrbracket + 1, \qquad
\llbracket D(E) \rrbracket = 2 \llbracket E \rrbracket.
\]

\subsection*{Expression graph}
We consider the \emph{expression graph}:
\begin{itemize}
    \item 0--cells: expressions $E$;
    \item 1--cells: edges $E \to T(E)$ and $E \to D(E)$.
\end{itemize}
This graph contains many paths that compute the same integer.

\section{Loops as Arithmetic Identities}

To introduce nontrivial topology, we incorporate a \emph{rewrite relation}:
\[
D(T(x)) \;\Longleftrightarrow\; T(T(D(x))),
\]
which is the syntactic reflection of the identity
\[
2(x+1) = 2x + 2.
\]
Each rewrite creates an additional 1--edge connecting two expressions of the same value.

\subsection*{Loops}
Different computation paths from $0$ to the same expression $E$,
when composed, produce a closed loop in the expression graph.
Such loops \emph{are arithmetic identities themselves}:
\[
E_1 = E_2 \quad \iff\quad
\gamma_1 \cdot \gamma_2^{-1} \;\text{is a loop}.
\]

\section{2--Cells: Filling Loops with Rewrite Rules}

A rewrite rule is modeled as a 2--cell.
For example, the loop:
\[
0 \xrightarrow{T} T(0) \xrightarrow{D} D(T(0))
  \xrightarrow{R} T(T(D(0))) \xleftarrow{T} T(D(0)) \xleftarrow{D} 0
\]
is taken as the boundary of a 2--cell $\sigma_1$.

Thus, a rewrite rule is not merely a syntactic equation but a
\emph{homotopy} between two paths.
Filling these loops corresponds to declaring certain identities ``basic''.

\section{Cochains and Algorithmic Invariants}

Given the 1--skeleton, a function on edges defines a 1--cochain.
The most important example is:
\[
\omega(T)=1, \qquad \omega(D)=0, \qquad \omega(R)=0,
\]
counting the number of $T$–steps modulo $2$.

\subsection*{Thue--Morse as a cochain integral}
For a path $\gamma$ from $0$ to $n$,
\[
\omega(\gamma) \equiv \text{(\# of $T$'s in $\gamma$)} \pmod 2.
\]
If we choose a canonical path to each $n$, this equals the Thue--Morse parity:
\[
t(n) = \mathrm{popcount}(n) \mod 2.
\]

\subsection*{Cocycle condition}
The key observation:
\[
\omega(\partial \sigma_i) = 0 \pmod 2
\]
for each 2--cell $\sigma_i$ coming from a rewrite rule.

Therefore $\omega$ descends to a cohomology class:
\[
[\omega] \in H^1.
\]

This explains why the recursive algorithm for Thue--Morse is compatible with
all rewrite laws: it is a genuine \emph{homological invariant}.

\section{Homology: Which Loops Are Essential?}

Let $C_1$ be the free abelian group generated by $T$ and $D$,
and let $r$ be the rewrite relation
\[
r:\; D T = T T D.
\]
As a group presentation:
\[
G = \langle T, D \mid DT = TTD \rangle.
\]

\subsection*{Abelianization}
Homology of the presentation complex satisfies:
\[
H_1(G) \cong G^{\mathrm{ab}}.
\]

In the abelianization, the relation becomes:
\[
D + T = D + 2T \quad\Rightarrow\quad T = 0.
\]
Therefore:
\[
H_1(G) \cong \mathbb Z.
\]

\subsection*{Interpretation}
Even though in a finite truncation ($\le 8$ or $\le 16$) many loops appear,
the \emph{global} homology has rank 1.
Every large loop is homologous to a multiple of the basic generator plus 2--cell boundaries.

This mathematically justifies: no ``new essential loops'' appear at higher truncations.

\section{Computation vs. Homology}

Two approaches coincide:

\begin{itemize}
    \item \textbf{Algorithmic view}:
    compute $t(n)$ by recursion
    \[
       t(2k)=t(k),\qquad t(2k+1)=1-t(k).
    \]
    \item \textbf{Homological view}:
    evaluate the cochain $\omega$ along a path from $0$ to $n$;
    $\omega$ is a cocycle, hence path–independent.
\end{itemize}

Thus:
\[
t(n) = \omega(\gamma_{0\to n}) \in H^1.
\]

\section{Relation to Learning}

The same structure becomes relevant to learning:

\begin{enumerate}
    \item \textbf{Learning a flow on the graph}:
          a model learns a distribution on computation paths.
    \item \textbf{Learning a cochain}:
          parameters define $\omega_\theta$;
          data fitting requires $\omega_\theta(\gamma_x)\approx y_x$,
          while coherence requires $\omega_\theta(\partial \sigma_i)\approx 0$.
    \item \textbf{Learning rewrite rules}:
          selecting which 2--cells to impose corresponds to learning
          which identities hold in the environment.
\end{enumerate}

Homotopy becomes a structural regularizer;
cohomology classes correspond to \emph{learned invariants}.

\section{Relation to Computation Theory \& Compilers}

This toy model illustrates a general principle:

\begin{itemize}
    \item Expressions/programs are 0--cells.
    \item Rewrite/optimization steps are 1--cells.
    \item Equational theorems/optimizations commute form 2--cells.
    \item Program invariants (cost, resources, parity, etc.) are cochains.
\end{itemize}

Thus homology/cohomology naturally measures:
\begin{itemize}
    \item Which program transformations are coherent;
    \item Which invariants survive all optimizations;
    \item Which optimizations introduce essential ``holes'' (nontrivial $H_1$).
\end{itemize}

This suggests a higher--dimensional view of compilers and learning systems.

\section{Conclusion}

The T/D toy model shows that:
\begin{quote}
\emph{Paths = computation.
Loops = arithmetic identities.
2--cells = rewrite rules.
Cochains = algorithmic invariants.
Homology = essential computational freedom.}
\end{quote}

This framework is small but fully generalizable.
It offers a unified perspective for expression geometry, computation,
program analysis, and modern learning theory.

\end{document}
